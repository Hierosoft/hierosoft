# -*- coding: utf-8 -*-
import unittest
import sys
import os
from unittest.util import (
    safe_repr,
)

my_dir = os.path.dirname(os.path.abspath(__file__))
module_dir = os.path.dirname(my_dir)
repo_dir = os.path.dirname(module_dir)

if __name__ == "__main__":
    sys.path.insert(0, repo_dir)  # insert grandparent to find parent module


from hierosoft import (  # noqa E402
    echo0,
    set_verbosity,
)

from hierosoft.morebytes import (  # noqa E402
    to_hex,
    keep_strip,
    find_not_quoted,
    tokenize_conf_line,
    split_before_newlines,
)


# MY_DIR = os.path.dirname(os.path.realpath(__file__))
# MODULE_DIR = os.path.dirname(MY_DIR)
# TEST_DATA_DIR = os.path.join(MY_DIR, "data")

# assert os.path.isdir(TEST_DATA_DIR)

class TestAlgorithms(unittest.TestCase):

    def test_to_hex(self):
        bytestring = "abcd".encode('utf-8')
        expected_s0 = '61626364'
        # ^ from Python 3.5+: "abcd".encode('utf-8').hex()
        expected_s1 = '61 62 63 64'
        # ^ from Python 3.5+: "abcd".encode('utf-8').hex(" ")
        self.assertEqual(to_hex(bytestring), expected_s0)
        self.assertEqual(to_hex(bytestring, delimiter=" "), expected_s1)

    def test_split_before_newlines(self):
        self.callAndAssertBytesAndStr(split_before_newlines, (" a\n"), (" a", "\n"))
        self.callAndAssertBytesAndStr(split_before_newlines, (" a \n"), (" a ", "\n"))
        self.callAndAssertBytesAndStr(split_before_newlines, ("a \n"), ("a ", "\n"))
        self.callAndAssertBytesAndStr(split_before_newlines, (" a\n "), (" a", "\n "))
        self.callAndAssertBytesAndStr(split_before_newlines, ("a \n "), ("a ", "\n "))
        # For files generated by Windows:
        self.callAndAssertBytesAndStr(split_before_newlines, (" a\r\n"), (" a", "\r\n"))
        self.callAndAssertBytesAndStr(split_before_newlines, (" a \r\n"), (" a ", "\r\n"))
        self.callAndAssertBytesAndStr(split_before_newlines, ("a \r\n"), ("a ", "\r\n"))
        # Edge cases, but latter portion is correct:
        self.callAndAssertBytesAndStr(split_before_newlines, (" a\n\n"), (" a", "\n\n"))
        self.callAndAssertBytesAndStr(split_before_newlines, (" a \n\n"), (" a ", "\n\n"))
        self.callAndAssertBytesAndStr(split_before_newlines, ("a \n\n"), ("a ", "\n\n"))

    def callAndAssertBytesAndStr(self, fn, arg, goodResult):
        """Make sure function works correctly with both bytes and str.

        Args:
            fn (function): function to run with arg.
            arg (str): arg to pass to fn
            goodResult: expected result of fn(arg)
        """
        self.assertEqual(fn(arg), goodResult)
        if isinstance(goodResult, (tuple, list)):
            newResult = []
            for value in goodResult:
                newResult.append(value.encode("utf-8"))
            if isinstance(goodResult, tuple):
                newResult = tuple(newResult)
            goodResult = newResult
        self.assertEqual(fn(arg.encode("utf-8")), goodResult)

    def assert_keep_strip_both(self, arg, goodValues):
        """Ensure keep_strip works with both bytes and str for the given arg

        Args:
            arg (str): A value to pass along to keep_strip as byte *and* str
            goodValues (str): The value that should result from keep_strip(arg)
        """
        # TODO: eliminate this method and use callAndAssertBytesAndStr instead
        gotValues = keep_strip(arg)
        self.assertEqual(gotValues, goodValues)

        pairs = []
        pairs.append((gotValues, goodValues))
        goodValues = tuple([s.encode("utf-8") for s in goodValues])
        # ^ must use list brackets directly around it or it will
        #   return a <generator object TestAlgorithms.assert_k[51 chars]7E60>
        arg = arg.encode("utf-8")
        gotValues = keep_strip(arg)
        self.assertEqual(
            gotValues,
            goodValues
        )
        pairs.append((gotValues, goodValues))

        for pair in pairs:
            gotValues, goodValues = pair
            for goodValue in goodValues:
                # If somehow the type difference didn't raise AssertionError,
                # raise manually:
                if type(arg) != type(goodValue):
                    # TODO: make tests to ensure the AssertionError was
                    #   already raised instead.
                    return AssertionError(
                        "gotValue is %s %s but goodValue is %s %s"
                        % (type(arg).__name__, safe_repr(arg),
                           type(goodValue).__name__, safe_repr(goodValue))
                    )

    def test_keep_strip(self):
        # TODO: Use callAndAssertBytesAndStr instead.
        self.assert_keep_strip_both(" = ", (" ", "=", " "))
        self.assert_keep_strip_both(" =", (" ", "=", ""))
        self.assert_keep_strip_both("= ", ("", "=", " "))
        self.assert_keep_strip_both("=", ("", "=", ""))
        self.assert_keep_strip_both(" some words ", (" ", "some words", " "))
        self.assert_keep_strip_both("  some words ", ("  ", "some words", " "))
        self.assert_keep_strip_both(" some words  ", (" ", "some words", "  "))
        self.assert_keep_strip_both("some words", ("", "some words", ""))
        self.assert_keep_strip_both("   ", ("   ", "", ""))

    def test_find_not_quoted(self):
        prefix = "[test_find_not_quoted] "
        good = {}
        good['comment'] = "  # some comment "
        good['name'] = "some name"
        good['sign'] = " = "
        good['value'] = "'can\\'t\"'"
        good['indent'] = "    "
        testdata = {}
        testdata['left_side'] = good['indent'] + good['name']
        # end_name_i = len(testdata['left_side'])
        testdata['indent_and_name_and_sign'] = \
            testdata['left_side'] + good['sign']
        start_value_quote_i = len(testdata['indent_and_name_and_sign'])
        skip_opening_quote_i = start_value_quote_i + 1
        # ^ +1 to skip first quote in good['value']
        # ^ *Must* provide already_in_quote="'" to find_not_quotes if used!
        testdata['all_except_comment'] = \
            testdata['indent_and_name_and_sign'] + good['value']
        # ^ just for creating good_endquote_i
        good_endquote_i = len(testdata['all_except_comment']) - 1
        haystack = testdata['all_except_comment'] + good['comment']
        escaped_quote_i = haystack.find("'", skip_opening_quote_i)
        self.assertNotEqual(escaped_quote_i, good_endquote_i)
        name_space_i = good['name'].index(" ") + len(good['indent'])
        good['sign_i'] = haystack.find(good['sign'])
        echo0(prefix+'checking "{}"'.format(haystack))
        self.assertEqual(find_not_quoted(haystack, good['indent']), 0)
        self.assertEqual(find_not_quoted(haystack, good['indent'][0]), 0)
        self.assertEqual(find_not_quoted(haystack, " ", len(good['indent'])),
                         name_space_i)
        self.assertEqual(find_not_quoted(haystack, "'"), start_value_quote_i)
        # ^ ' should be able to be found even if it is the open quote
        only_sign = good['sign'].lstrip()
        sign_indent = len(good['sign']) - len(only_sign)
        only_sign = only_sign.strip()
        only_sign_i = good['sign_i'] + sign_indent
        self.assertEqual(find_not_quoted(haystack, only_sign), only_sign_i)
        self.assertEqual(find_not_quoted(haystack, good['sign']),
                         good['sign_i'])
        got_endquote_i = find_not_quoted(haystack, "'", skip_opening_quote_i,
                                         already_in_quote="'")
        if got_endquote_i == escaped_quote_i:
            echo0("escaping error: ' after %s should be ignored at %s"
                  % ("\\", escaped_quote_i))
        self.assertEqual(
            got_endquote_i,
            good_endquote_i
        )
        # ^ ' should be able to be found if starting after the opening quote
        #     (but escaped quote should not be)
        self.assertEqual(  # ensure escaped escape doesn't escape next
            find_not_quoted("'\\\\'", "'", 1, already_in_quote="'"),
            3
        )

        self.assertEqual(  # ensure escaped escape doesn't escape next
            find_not_quoted("'\\\\'", "'", 1, already_in_quote="'"),
            3
        )

    def test_tokenize_conf_line(self):
        # prefix = "[test_tokenize_conf_line] "
        good = {}
        good['indent'] = "    "
        good['name'] = "some name"
        good['sign'] = " = "
        good['value'] = "'can\\'t\"'"
        good['space_after_value'] = "  "
        good['comment'] = "# some comment "
        good['newline'] = "\n"
        testdata = {}
        testdata['left_side'] = good['indent'] + good['name']
        # end_name_i = len(testdata['left_side'])
        testdata['indent_and_name_and_sign'] = (testdata['left_side']
                                                + good['sign'])
        # start_value_quote_i = len(testdata['indent_and_name_and_sign'])
        # skip_opening_quote_i = start_value_quote_i + 1
        # ^ +1 to skip first quote in good['value']
        testdata['all_except_comment'] = (testdata['indent_and_name_and_sign']
                                          + good['value'])
        # ^ just for creating good_endquote_i
        # good_endquote_i = len(testdata['all_except_comment']) - 1
        haystack = (testdata['all_except_comment'] + good['space_after_value']
                    + good['comment'] + good['newline'])
        # name_space_i = good['name'].index(" ") + len(good['indent'])
        # good['sign_i'] = haystack.find(good['sign'])
        print('Tokenizing """%s"""' % haystack)
        self.assert_tokenize_conf_line_both(haystack, good)

    def assert_tokenize_conf_line_both(self, haystack, good):
        self.assert_tokenize_conf_line(haystack, good,
                                       "[test_tokenize_conf_line with str] ")
        haystack = haystack.encode("utf-8")
        for key, value in good.items():
            good[key] = value.encode("utf-8")
        self.assert_tokenize_conf_line(
            haystack, good, "[test_tokenize_conf_line with bytes] "
        )
        # ^ prefix is never bytes--only combined with formatted message

    def assert_tokenize_conf_line(self, haystack, good, prefix):
        echo0(prefix+'checking "{}"'.format(haystack))
        tokens = tokenize_conf_line(haystack, True)
        print(prefix+"tokens=%s" % tokens)
        indent, name, sign, value, space_after_value, comment, newline = tokens
        self.assertEqual(space_after_value, good['space_after_value'])
        self.assertEqual(indent, good['indent'])
        self.assertEqual(name, good['name'])
        self.assertEqual(sign, good['sign'])
        self.assertEqual(value, good['value'])
        self.assertEqual(comment, good['comment'])
        self.assertEqual(newline, good['newline'])
        del haystack

        comment_line = good['comment']
        echo0(prefix+'checking "{}"'.format(comment_line))
        tokens = tokenize_conf_line(comment_line, True)
        indent, name, sign, value, space_after_value, comment, newline = tokens
        good_blank = ""
        if type(comment_line).__name__ != "str":
            good_blank = good_blank.encode("utf-8")
        self.assertEqual(indent, good_blank)
        self.assertTrue(name is None)
        self.assertTrue(sign is None)
        self.assertTrue(value is None)
        self.assertEqual(comment, good['comment'])
        del comment_line

        blank_line = "\n"
        echo0(prefix+'checking "{}"'.format(blank_line))
        tokens = tokenize_conf_line(blank_line, True)
        indent, name, sign, value, space_after_value, comment, newline = tokens
        self.assertEqual(indent, "")
        self.assertTrue(name is None)
        self.assertTrue(sign is None)
        self.assertTrue(value is None)
        self.assertTrue(comment is None)
        self.assertEqual(newline, blank_line)


if __name__ == "__main__":
    testcase = TestAlgorithms()
    count = 0
    for name in dir(testcase):
        if name.startswith("test"):
            fn = getattr(testcase, name)
            fn()  # Look at def test_* for the code if tracebacks start here
            count += 1
    echo0("{} test(s) passed.".format(count))
