#!/usr/bin/env python
'''
checkpath
---------

Author: Jake "Poikilos" Gustafson

Check the environment's PATH variable (not the sys.path which is just
for Python). Get commands that can shorten your PATH if it has
redundant or nonexistant directories. In most cases, if your user has
a PATH, it is wrong. However, you can get a copy of it safely using
this program by running it with the redirect below.

GNU/Linux and similar systems usually don't mess up the PATH like
Windows programs do, so by default the --include-bad-parts option is
turned on if not using Windows. Use the --no-bad-parts option if you
want to exclude directories that don't exist (But generally don't.
You probably need them in there anyway such as in case a program gets
installed to /usr/local/bin or some other optional bin directory).

Even on Windows, don't use the default commands generated by this
submodule unless you know what you're doing. There could be instances
where directories that don't exist yet are still important, such as
C:\\Program Files\\nodejs\\node_modules\\.bin or other directories that
are meant to contain executables in certain circumstances.

If you are using one or more versions of MS SQL Server, you should
remove those first, since your PATH is likely corrupt (truncated at the
end) and maxxed out, causing any programs installed after that (such as
nvm or potentially Node.js itself) to not be able to correctly add
folders to the PATH that need to be there for your computer to work
properly!


Usage:
{checkpath} [other paths] [options]
# or preferably:
python pathcheck.py [other paths] | tee -a path_history.bat
# ^ Save the OLD_PATH, BAD_PATH_PARTS, and the set PATH statement.

Options:
other paths            Specify another path as the first argument if you
                       want to see what paths are not yet in the sytem
                       path. The other paths, if more than one, should
                       be separated by your operatings path separator
                       character '{pathsep}' (*not* the directory
                       separator '{dirsep}').
                       - If you do not specify any arguments, only
                         duplicates already in the PATH will be removed
                         from the recommended setx PATH statement.

--no-bad-parts         Exclude bad parts from the path (on by default in
                       Windows.

--include-bad-parts    Include even non-existant folders in the
                       recommended PATH string.
{command_prompt_requires_starting_with_python_or_loses_args}
'''
from __future__ import print_function
import sys
import os
import platform

NOOP = "# "
INLINE_NOOP = "# "
if platform.system() == "Windows":
    NOOP = "REM "
    INLINE_NOOP = "\nREM ^ "


default_bad_enabled = True
if platform.system() == "Windows":
    default_bad_enabled = False

from moreplatform import (
    echo0,
    echo1,
    echo2,
    set_verbosity,
)

def show_truncations(new_path, enable_stdout=True, comment=None):
    '''
    Keyword arguments:
    enable_stdout -- Write the set PATH statement to standard output
        (If False, only write to stderr).
    comment -- Show this as a commented line before the statement.
    '''
    thisp = print
    if not enable_stdout:
        thisp = echo0
    setx_max = 1024
    if comment is not None:
        thisp(NOOP+comment)
    thisp(NOOP+"Non-commented generated paths below are")
    thisp(NOOP+"recommended by checkpath (Python script by Poikilos).")
    thisp(NOOP+"- checkpath excludes redundant and non-existant folders.")
    if platform.system() == "Windows":
        echo0("setx truncates to 1024 characters.")
        trunc2048_new_path = new_path[:2048]
        for max_len in [1024, 2048]:
            trunc_new_path = new_path[:max_len]
            echo0()
            echo0("Example (new_path, <={} chars):".format(max_len))
            prefix = ""
            if trunc_new_path != new_path:
                thisp(NOOP+"WARNING: Truncated to {} characters:"
                      "".format(max_len))
                prefix = NOOP
            else:
                thisp(NOOP+"{} character(s)".format(len(trunc_new_path)))
            cmd_fmt = 'setx /M PATH "{}"'
            if len(trunc_new_path) > setx_max:
                thisp(NOOP+"Error: You must use reg, regedit, or System,"
                      " Advanced System Settings,"
                      " Environment Variables editor to set a path as"
                      " long as the recommended one below."
                      "\n"+NOOP
                      + "- Your path is {} character(s) which is > {}"
                      " allowed by setx"
                      " (otherwise it truncates and corrupts it!):"
                      "".format(len(trunc_new_path), setx_max))
                prefix = NOOP
                # cmd_fmt = '"{}"'
                cmd_fmt = ('reg ADD "HKLM\\SYSTEM\\CurrentControlSet\\'
                           'Control\\Session Manager\\Environment"'
                           ' /v Path /t REG_EXPAND_SZ /d "{}" /f')
                # ^ as per <https://stackoverflow.com/a/35248331/4541104>
                #   EXCEPT "Session Manager" not "Sessions Manager".
                # ^ tested via reg QUERY "HKLM\SYSTEM\CurrentControlSet\
                #   Control\Session Manager\Environment" /v PATH
            thisp('{}{}'.format(prefix, cmd_fmt.format(trunc_new_path)))
            # ^ /M: machine setting rather than user setting
            if new_path != trunc_new_path:
                echo0("(truncated to {})".format(len(trunc_new_path)))
            else:
                echo0("(not truncated, {} char(s))".format(len(trunc_new_path)))
        echo0("Make sure you run setx /M commands in Command Prompt"
              " (Administrator). Without /M, it will affect"
              " only the user PATH and if that is present"
              " then this script will not be able to diagnose the system PATH.")
    else:
        echo0("operating system: {} shouldn't have problems,"
              " but if there is a PATH limit,"
              " be sure not to exceed that when setting PATH."
              "".format(platform.system()))
        print('PATH="{}"'.format(new_path))


def check_path(custom_path=None, bad_enabled=True):
    '''
    Keyword arguments:
    bad_enabled -- Include non-existant directories in the recommended
        PATH.
    '''
    original_path = os.environ['PATH']
    original_paths = original_path.split(os.pathsep)
    # os.pathsep: something like ;
    # os.path.sep: something like \
    new_paths = []
    bad_paths = []
    unique_paths = []
    for path in original_paths:
        if len(path.strip()) == 0:
            continue
        if path in unique_paths:
            continue
        unique_paths.append(path)
        if os.path.isdir(path):
            new_paths.append(path)
        else:
            bad_paths.append(path)
    unique_path = os.pathsep.join(unique_paths)
    command_reason = " (checkpath "
    if default_bad_enabled != bad_enabled:
        if bad_enabled:
            command_reason += "--no-bad-paths"
        else:
            command_reason += "--include-bad-paths"
    else:
        if bad_enabled:
            command_reason += INLINE_NOOP+"didn't say --no-bad-paths"
        else:
            command_reason += INLINE_NOOP+"didn't say --include-bad-paths"
        command_reason += " to change default for " + platform.system()
        command_reason += ")"
    if bad_enabled:
        print(NOOP+"{} nonexistant path(s) included in recommended{}"
              "".format(len(bad_paths), command_reason))
        new_paths += bad_paths
    new_path = os.pathsep.join(new_paths)
    bad_path = os.pathsep.join(bad_paths)
    echo0("original_paths ({} chars): {}"
          "".format(len(original_path), original_path))
    echo0("unique_paths ({} chars): {}".format(len(unique_path), unique_path))
    echo0("- splits into:")
    echo0("  * new_paths ({} chars): {}".format(len(new_path), new_path))
    echo0("  * bad_paths ({} chars): {}".format(len(bad_path), bad_path))
    print('OLD_PATH="{}"'.format(original_path))
    print('BAD_PATH_PARTS="{}"'.format(bad_path))
    enable_stdout = custom_path is not None
    show_truncations(new_path, enable_stdout=enable_stdout)
    echo0()

    if custom_path is None:
        return 0
    print()
    echo0()

    custom_paths = custom_path.split(os.pathsep)
    echo0("* adding {} path(s) from {}"
          "".format(len(custom_paths), custom_path))
    recommended_not_in_arg = []
    arg_not_in_recommended_yet = []
    arg_not_current_yet = []
    for path in new_paths:
        if path not in custom_paths:
            recommended_not_in_arg.append(path)
    for path in custom_paths:
        if len(path.strip()) == 0:
            continue
        if path not in new_paths:
            arg_not_in_recommended_yet.append(path)
        if path not in unique_paths:
            arg_not_current_yet.append(path)

    # Some wording is redundant so each set's label is shown on the
    #   screen (at least to stderr) whether or not stdout is redirected:

    sys.stdout.write(
        NOOP+'{} you specified are not yet in the calculated path above'
        ''.format(len(arg_not_in_recommended_yet))
    )
    echo0(": arg_not_in_recommended_yet="
          + os.pathsep.join(arg_not_in_recommended_yet))
    print()
    sys.stdout.write(
        NOOP+'{} you specified are not yet in the current PATH'
        ''.format(len(arg_not_current_yet))
    )
    echo0(": arg_not_current_yet="+os.pathsep.join(arg_not_current_yet))
    print()
    sys.stdout.write(
        NOOP+'{} already in the calculated path are not in your specified path'
        ''.format(len(recommended_not_in_arg))
    )
    echo0(": recommended_not_in_arg="+os.pathsep.join(recommended_not_in_arg))
    print()
    new_paths += arg_not_in_recommended_yet
    new_path = os.pathsep.join(new_paths)
    show_truncations(
        new_path,
        enable_stdout=enable_stdout,
        comment="With (new paths only from) your specified additions:",
    )
    echo0()
    return 0


windows_command_note = '''
If you are using Windows Command Prompt, you must run the command
starting with python (python checkpath.py). Otherwise (If you run it
like: .\\checkpath.py), all of the arguments are stripped off :(.
However, Windows Terminal/PowerShell doesn't have the problem.
'''


def usage():
    # os.pathsep: something like ;
    # os.path.sep: something like \
    note = ""
    command = sys.argv[0]
    if platform.system() == "Windows":
        command = "python checkpath.py"
        # ^ See the windows_command_note global.
        note = windows_command_note
    echo0(__doc__.format(
        pathsep=os.pathsep,
        dirsep=os.path.sep,
        checkpath=sys.argv[0],
        command_prompt_requires_starting_with_python_or_loses_args=note,
    ))


# Latitude E6410 Windows 10 Laptop least mangled path
# (after setx truncated it since it was already doubled):
# see Latitude_E6410_old_path.txt


def main():
    custom_path = None

    bad_enabled = default_bad_enabled

    for i in range(1, len(sys.argv)):
        arg = sys.argv[i]
        if arg == "--verbose":
            set_verbosity(1)
        elif arg == "--debug":
            set_verbosity(2)
        elif arg == "--help":
            usage()
            return 0
        elif arg == "--no-bad-parts":
            bad_enabled = False
        elif arg == "--include-bad-parts":
            bad_enabled = True
        elif custom_path is None:
            custom_path = arg
        else:
            usage()
            echo0("Error: There was an extra argument: {}"
                  "".format(arg))
            return 1
    return check_path(custom_path=custom_path, bad_enabled=bad_enabled)


if __name__ == "__main__":
    sys.exit(main())
