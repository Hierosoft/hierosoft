# -*- coding: utf-8 -*-
'''
Specialized Minetest metadata and methods for HInstaller.

Globals:
    project_metas (dict): prepackaged install metadata for well-known
        programs.
        - 'name' (Optional[str]): The entire name (except variant) that
          should be displayed as the shortcut's caption.
        - 'name_and_variant_fmt' (Optional[str]): Should either be not
          present or contain the name and the placeholder "{}" where the
          variant should go. If not present, " " and variant will be
          added to the end of Name.
        - 'shortcut' (dict): contains:
          - 'Name' (Optional[str]): If set, name and
            name_and_variant_fmt could be excluded in calls to any
            installer functions. 'Name' is generated by generate_caption
            in the case of Minetest unless a non-detecting is used, as
            opposed to install-lmk which detects variant etc.
'''
from __future__ import print_function

import copy
import os

from hierosoft.morelogging import pformat

from hierosoft import (
    echo0,
)

MINETEST_KEYWORDS = ("sandbox;world;mining;crafting;blocks;nodes;multiplayer;"
                     "roleplaying;")

project_metas = {
    'classic': {  # minetest is the project name (in mtsrc/newline dir)
        'project_name': "classic",
        'shortcut': {
            'GenericName': "Final Minetest",
            'Keywords': MINETEST_KEYWORDS,
            # 'Name': before calling install, set from choices below
        },
        'dirname': "minetest",
        'name_and_variant_fmt': "Final Minetest ({})",
        # ^ such as (local) etc.
        'name': "Final Minetest",
        'shortcut_exe_relpaths': [
            os.path.join("bin", "minetest"),
        ],
        'platform_icon_relpath': {
            'Linux': os.path.join("misc", "minetest.svg"),
            'Darwin': os.path.join("misc", "minetest-icon.icns"),
            'Windows': os.path.join("misc", "minetest-icon-24x24.png"),
        },
        'shortcut_relpath': os.path.join("misc",
                                         "net.minetest.minetest.desktop"),
        'shortcut_namespace': "org.minetest.minetest",
    },
    'finetest': {
        'project_name': "finetest",
        'shortcut': {
            'GenericName': "Finetest",
            'Keywords': MINETEST_KEYWORDS+"minetest;",
            # 'Name': before calling install, set from choices below
        },
        'dirname': "finetest",
        'name_and_variant_fmt': "Finetest ({})",
        'name': "Finetest",
        'shortcut_exe_relpaths': [
            # os.path.join("bin", "multicraft"),
            os.path.join("bin", "finetest"),
        ],
        'platform_icon_relpath': {
            'Linux': os.path.join("misc", "multicraft-xorg-icon-128.png"),
            'Darwin': os.path.join("misc", "minetest-icon.icns"),
            'Windows': os.path.join("misc", "multicraft-xorg-icon-128.png"),
        },
        'shortcut_relpath': os.path.join("misc",
                                         "net.minetest.minetest.desktop"),
        'shortcut_namespace': "org.minetest.finetest",
    },
    'trolltest': {
        'project_name': "trolltest",
        'shortcut': {
            'GenericName': "Trolltest",
            'Keywords': MINETEST_KEYWORDS+"minetest;",
            # 'Name': before calling install, set from choices below
        },
        'dirname': "trolltest",
        'name_and_variant_fmt': "Trolltest ({}) (minetest.org build)",
        'name': "Trolltest (minetest.org)",
        'shortcut_exe_relpaths': [
            os.path.join("bin", "trolltest"),
        ],
        'platform_icon_relpath': {
            'Linux': os.path.join("misc", "minetest.svg"),
            'Darwin': os.path.join("misc", "minetest-icon.icns"),
            'Windows': os.path.join("misc", "minetest-icon-24x24.png"),
        },
        'shortcut_relpath': os.path.join("misc",
                                         "net.minetest.minetest.desktop"),
        'shortcut_namespace': "org.minetest.trolltest",
    },
}

for _name, _meta in project_metas.items():
    _meta['project_name'] = _name


def detect_project_meta(mt_share_path):
    """Detect the project info from a source *or* destination.

    Only first entry will be used & get "server" added.

    Args:
        mt_share_path (string): The path containing
            project_meta['shortcut_exe_relpaths']
            filename(s).

    Returns:
        A copy of the matching project_meta (from project_metas) with
        an added entry 'required_relpaths'.
        - *detecting errors*: If the list length is 0 or the key is not
          present, no required files were found and the install source
          is not understandable (There is no known binary such as for
          different code to make a shortcut).
        - If relpath+"server" exists in the case of the first entry in
          'shortcut_exe_relpaths', that server binary will be added to
          the 'required_relpaths' list whether or not the filename
          without "server" in the name exists.
    """
    prefix = "[detect_project_meta] "
    matches = []
    for mode, meta in project_metas.items():
        new_meta = copy.deepcopy(meta)
        if 'required_relpaths' not in new_meta:
            new_meta['required_relpaths'] = \
                meta['shortcut_exe_relpaths'].copy()
        for sub in meta.get('shortcut_exe_relpaths'):
            sub_path = os.path.join(mt_share_path, sub)
            try_extra_rel = sub + "server"
            try_extra_exe = os.path.join(mt_share_path, try_extra_rel)
            found_any = False
            if os.path.isfile(try_extra_exe):
                found_any = True
                if try_extra_rel not in new_meta['required_relpaths']:
                    new_meta['required_relpaths'].append(try_extra_exe)
                    # For example, bin/minetestserver is required
                    #   if in --server install mode (and this
                    #   function detects that mode)
                    #   but there is no shortcut to it in the GUI.
            else:
                echo0(prefix+"There is no %s" % try_extra_exe)
            if os.path.isfile(sub_path):
                found_any = True
            else:
                echo0(prefix+"There is no %s" % sub_path)
                new_meta['required_relpaths'].remove(sub)
                # For example, remove "minetest" if not present (but
                #   install can still proceed if "minetestserver" was
                #   added to the required list).
            mt_share_path = os.path.realpath(mt_share_path)
            version_paths = [
                os.path.join(mt_share_path, "release.txt"),
                os.path.join(os.path.dirname(mt_share_path), "release.txt"),
            ]
            for version_path in version_paths:
                if os.path.isfile(version_path):
                    new_meta['version_path'] = version_path
                    version = None
                    with open(version_path, 'r') as stream:
                        for rawL in stream:
                            if version is None:
                                version = rawL.strip()
                        # ^ Use `for` to avoid Exception on empty file.
                    if version is None:
                        echo0('Warning: "{}" is empty!'.format(version_path))
                        continue
                    elif not version:
                        echo0('Warning: "{}" had a blank line not version'
                              ''.format(version_path))
                        version = None
                        continue
                    if version:
                        new_meta['version'] = version
                        break
            if found_any:
                matches.append(new_meta)
                break  # only first entry will be used & get "server" added
    if len(matches) == 1:
        echo0(prefix+"found source files: %s"
              % pformat(matches[0]['required_relpaths']))
        return matches[0]
    return None
